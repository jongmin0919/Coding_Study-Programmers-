// 문제 이해 : 기본은 n/2 마리의 포켓몬을 가져갈수 있다고 하자. 예를 들어 포켓몬이 [3,1,2,3] 이렇게 네 마리라면 4/2가 되는 것이고, 그래서 2마리를 가져갈 수 있게 된다. 다시 [3,3,3,2,2,4] 이렇게 여섯마리의 포켓몬이 여섯 마리라면 6/2가 되어 3마리를 가져갈 수 있다. 그러나 [3,3,3,2,2,2] 이런 상황에서는 6/2가 아니라 포켓몬이 두 종료 밖에 되지 않기 때문에 4/2의 결과(2마리)가 나타나게 된다.

function solution(nums) {
    const select = nums.length/2;
// select 변수에 배열 길이를 2로 나눈 값을 할당하고
    const check = nums.reduce((total,cur) => {
// check 변수에는 reduce 함수를 사용해 check에 반환할 total의 객체 상태를 빈 문자열로 초기화( {} )를 합니다. 그 후 배열을 순회하면서 현재 total 객체 안에 total[cur(key)]이 true, 즉 값이 들어있다면 삼항연산에 의한 true값(현재 키 값 증가)이 실행되고, false, 포켓몬이 아직 없을 경우 false항(해당 키에 값을 1로 정의) 하는 작업을 수행합니다. 
        total[cur] ? total[cur]++ : total[cur] = 1;
        return total;
// 순회 작업이 끝나면 total(누적된 객체)를 반환합니다.
    },{});
    const checkLeng = Object.keys(check).length;
// checkLeng에 반환 받은 check 배열의 키의 갯수(length)를 입력합니다.
    return checkLeng > select ? select : checkLeng;
// 만약 checkLeng의 길이, 즉 포켓몬의 종류가 전체 포켓몬을 2로 나눈 값보다 많을 경우에는 select를, 그렇지 않다면 checkLeng을 트레이너가 받게 됩니다. 이게 무슨 뜻이냐면, [3,1,2,3] 이 입력 되었다면 select는 2가 되고, check는 3이 될텐데 포켓몬 종류는 3종인데 반해 트레이너가 현재 선택 가능한 마리수는 최대 2마리 이므로 2마리를 가져가게 됩니다. 다시 돌아와 만약 [3,3,3,2,2,2] 두 종류의 포켓몬이 여섯마리 존재 한다면 사용자가 최대로 가져갈 수 있는 포켓몬은 3마리 이지만, 종류는 2마리 밖에 없기 때문에 2마리만 가져가게 됨을 의미하죠.
//정리하자면, 선택할 수 있는 포켓몬 수에 비해 포켓몬 종류가 많을 경우 그냥 2마리만 가져가고, 선택 가능한 포켓몬 수가 종류보다 적은 경우 그냥 종류대로 가지는 케이스 입니다. 
// 만약 [3,3,3,2,2,2,1,1,1,4]가 입력 되었다면 포켓몬 종류는 4종인데 반해 선택 가능한 수는 5마리가 되니까 이 경우에도 마찬가지로 그냥 종류대로 가져가는(4마리) 결과가 반환 되는 것이죠.
}