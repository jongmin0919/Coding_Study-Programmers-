/*
function solution(arr) {
    const newArr = [];
    
    for (let i = 0; i < arr.length; i++) {
        if (newArr.indexOf(arr[i]) === -1) {
// 빈 배열의 newArr에서 현재 arr[i]의 인덱스가 -1이라면, 즉 해당 값에 대한 인덱스가 없다면 arr[i] 의 값을 newArr에 할당하는 로직을 구현하였습니다. 그렇게 된다면 다음 중복되는 숫자는 이전 할당된 값의 인덱스가 존재하므로 다음 for문으로 이어가게 했는데요. 음... 다시 등장하는 문자에 대한 부분을 처리하기 어려워 이 방법은 킾하는걸로 했습니다.
            newArr.push(arr[i]);
        } 
    }    
    return newArr;
}
*/

function solution(arr)
{
    let answer = [];

    let j = 1;
    // j를 1로 초기화하는데 왜 1로 설정을 했는지 의문이였는데, 생각을 해보니 첫번째 숫자와 두번째 숫자가 같으면 애초에 for문이 적용 되지 않고, 다를 경우 현재의 값(i)이 answer의 j(첫번째) 배열에 담기기 때문에 예제의 경우 1이 아니라 3이 담기게 된다. 그래서 이런 에러를 방지하고자 미리 j를 1로 설정하고 answer의 첫번째 배열에 arr의 첫번째 값을 담음으로서 최초의 배열값을 담는 보장을 한것으로 본다. 
    answer[0] = arr[0];
    // answer배열의 첫번째에 arr배열의 첫번째 값을 할당
    for (let i = 1; i < arr.length; i++){
    // for문을 돌려 i를 1부터 시작해서
        if(arr[i-1] !== arr[i]){
    // 만약 주어진 배열의 현재 i의 이전번째 값이 현재 i번째 값과 다를 경우
            answer[j] = arr[i];
    // answer 배열의 j(처음은 1)에 arr[i](이전과 다른 값)을 넣고
            j++;
    // j(answer의 다음 배열 인덱스)를 증가시킵니다.
        }
    }
//for문을 돌렸을 때 변화되는 로직은 다음과 같습니다.
/*
[1, 1, 3, 3, 0, 1, 1]
[1] 			 J=1

[1, 1, 3, 3, 0, 1, 1]
[1,3,] 			 J=2

[1, 1, 3, 3, 0, 1, 1]
[1,3,] 			 J=2

[1, 1, 3, 3, 0, 1, 1]
[1,3,0] 			 J=3

[1, 1, 3, 3, 0, 1, 1]
[1,3,0,1] 			 J=4

[1, 1, 3, 3, 0, 1, 1]
[1,3,0,1] 			 J=4
*/
// 그리고 현재의 i값과 그 다음 i값(i+1) 을 비교하지 않은 이유에 대해서는, 마지막 i번째 값 다음의 i+1의 값이 없기 때문에, 이전의 값(i-1)과 현재의 값(i)를 비교한 것으로 보인다.
    return answer;
}