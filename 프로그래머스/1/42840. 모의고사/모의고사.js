// 문제 해설 : 수포자의 찍기 패턴은 일정하므로 일정한 패턴값 만큼 각각의 배열로 생성합니다. (Array) 그 후 정답 배열이 넘어오면 해당 배열의 길이만큼 정답과 각 수포자들의 찍기 배열의 값을 순차적으로 비교하여 정답을 맞췄을 경우 맞춘 횟수(sum)를 증가시키고 최종적으로 생성된 sum 배열에서 가장 큰 값을 가진 인덱스를 출력하는 코드입니다. 
// 이때 각각의 수포자들의 일정한 찍기 패턴값을 담은 배열 길이는 각자 다르기 때문에, 나머지 연산을 활용해서 각각의 배열이 순회되면서 비교되는 알고리즘을 구현하면 됩니다.

function solution(answers) {
    let answer = []; // 반환할 answer 배열 초기화
    const Array = [[1, 2, 3, 4, 5], [2,1,2,3,2,4,2,5], [3,3,1,1,2,2,4,4,5,5]];
    // Array 배열에 각각의 수포자들의 일정한 찍기 패턴값을 배열로 입력합니다.

    let sum = [0,0,0];
    
    // 각각의 수포자들의 문제를 맞춘 횟수를 저장할 sum 배열을 초기화 합니다.

    for(let i = 0; i < 3; i++){ // 3개의 배열을 각각 돌면서
        for(let j = 0; j < answers.length; j++) { // 정답이 열개가 입력되었다고 가정한다면
            if (answers[j] === Array[i][j % (Array[i].length)]) {
// ① 정답 배열은 순차적으로 돌테고, Array의 첫번째 수포자 배열을 돈다고 가정하면 [1][j%5](첫번째 수포자 배열의 길이) 값과 비교를 할테니 0,1,2,3,4까지 나머지가 출력되어 해당 값을 비교할 것입니다.
// ② 이후 j가 5가 되는 순간 나머지는 0이니 결국 Array[i][0] 로 돌아와서 해당 과정을 반복하게 될것입니다. 이러한 알고리즘으로 나머지 배열인 두번째, 세번째 수포자 배열 또한 각각의 배열을 반복적으로 순회하며 값을 비교할 수 있게 되는 것이죠.
                sum[i]++;
                // 그렇게 위의 조건대로 정답과 수포자 배열의 찍기 값이 같을 경우 해당 수포자의 정답값을 누적 증가시킵니다.
            }
        }
    }
    let max = Math.max(sum[0], sum[1], sum[2]);
    // 해당 for문이 종료된 후 max 메서드를 이용해 세 배열 중 가장 큰 값을 찾습니다.

    if (max === sum[0]) {
    // 만약 가장 큰 값이 첫번째 수포자의 값과 같다면, 즉 최다 득점자가 첫번째 수포자라면
        answer.push(1);
    // answer 배열에 첫번째 수포자를 의미하는 1을 입력하고
    }
    if (max === sum[1]) {
        answer.push(2);
    }
    if (max === sum[2]) {
        answer.push(3);
    }
    // 두번째, 세번째 수포자에 대한 조건값 또한 동일하게 조건문을 입력하는데, else if를 사용하지 않고 개별의 if문으로 작성하는 이유는 동점자가 나올 경우를 대비해서 개별 if문을 사용한 것입니다.

    return answer;
}